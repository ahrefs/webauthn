<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Webauthn (webauthn.Webauthn)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">webauthn</a> &#x00BB; Webauthn</nav><header class="odoc-preamble"><h1>Module <code><span>Webauthn</span></code></h1></header><div class="odoc-content"><p>WebAuthn - authenticating users to services using public key cryptography</p><p>WebAuthn is a web standard published by the W3C. Its goal is to standardize an interfacefor authenticating users to web-based applications and services using public key cryptography. Modern web browsers support WebAuthn functionality.</p><p>WebAuthn provides two funcitons: register and authenticate. Usually the public and private keypair is stored on an external token (Yuikey etc.) or part of the platform (TPM). After the public key is registered, it can be used to authenticate to the same service.</p><p>This module implements at the moment only &quot;fido-u2f&quot; and &quot;none&quot; attestations with P256 keys.</p><p>A common use of this module is that on startup a <a href="#type-t"><code>t</code></a> is created (using <a href="#val-create"><code>create</code></a>). A public key can then be registered (<a href="#val-register"><code>register</code></a>) with a server generated <a href="#type-challenge"><code>challenge</code></a>. When this is successfull, the client can be authenticated <a href="#val-authenticate"><code>authenticate</code></a>.</p><p>This module does not preserve a database of registered public keys, their credential ID, usernames and pending challenges - instead this data must be stored by a client of this API in a database or other persistent storage.</p><p><a href="https://w3c.github.io/webauthn/">WebAuthn specification at W3C.</a></p><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of a webauthn state, containing the <code>origin</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>create origin</code> is a webauthn state, or an error if the origin does not meet the specification (schema must be https, the host must be a valid hostname. An optional port is supported: https://example.com:4444</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rpid" class="anchored"><a href="#val-rpid" class="anchor"></a><code><span><span class="keyword">val</span> rpid : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>rpid t</code> is the relying party ID. Specifically, it is the effective domain of the origin. Using registrable domain suffix as the relying party ID is currently unsupported.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-json_decoding_error" class="anchored"><a href="#type-json_decoding_error" class="anchor"></a><code><span><span class="keyword">type</span> json_decoding_error</span><span> = </span><span>[ </span></code><table><tr id="type-json_decoding_error.Json_decoding" class="anchored"><td class="def constructor"><a href="#type-json_decoding_error.Json_decoding" class="anchor"></a><code><span>| </span></code><code><span>`Json_decoding <span class="keyword">of</span> string * string * string</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type os json decoding errors: context, message, and data.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-decoding_error" class="anchored"><a href="#type-decoding_error" class="anchor"></a><code><span><span class="keyword">type</span> decoding_error</span><span> = </span><span>[ </span></code><table><tr id="type-decoding_error.json_decoding_error" class="anchored"><td class="def type"><a href="#type-decoding_error.json_decoding_error" class="anchor"></a><code><span>| </span></code><code><span><a href="#type-json_decoding_error">json_decoding_error</a></span></code></td></tr><tr id="type-decoding_error.Base64_decoding" class="anchored"><td class="def constructor"><a href="#type-decoding_error.Base64_decoding" class="anchor"></a><code><span>| </span></code><code><span>`Base64_decoding <span class="keyword">of</span> string * string * string</span></code></td></tr><tr id="type-decoding_error.CBOR_decoding" class="anchored"><td class="def constructor"><a href="#type-decoding_error.CBOR_decoding" class="anchor"></a><code><span>| </span></code><code><span>`CBOR_decoding <span class="keyword">of</span> string * string * string</span></code></td></tr><tr id="type-decoding_error.Unexpected_CBOR" class="anchored"><td class="def constructor"><a href="#type-decoding_error.Unexpected_CBOR" class="anchor"></a><code><span>| </span></code><code><span>`Unexpected_CBOR <span class="keyword">of</span> string * string * <span class="xref-unresolved">CBOR</span>.Simple.t</span></code></td></tr><tr id="type-decoding_error.Binary_decoding" class="anchored"><td class="def constructor"><a href="#type-decoding_error.Binary_decoding" class="anchor"></a><code><span>| </span></code><code><span>`Binary_decoding <span class="keyword">of</span> string * string * <span class="xref-unresolved">Cstruct</span>.t</span></code></td></tr><tr id="type-decoding_error.Attestation_object_decoding" class="anchored"><td class="def constructor"><a href="#type-decoding_error.Attestation_object_decoding" class="anchor"></a><code><span>| </span></code><code><span>`Attestation_object_decoding <span class="keyword">of</span> string * string * string</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The variant of decoding errors with the various encoding formats.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-error" class="anchored"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span><span> = </span><span>[ </span></code><table><tr id="type-error.decoding_error" class="anchored"><td class="def type"><a href="#type-error.decoding_error" class="anchor"></a><code><span>| </span></code><code><span><a href="#type-decoding_error">decoding_error</a></span></code></td></tr><tr id="type-error.Unsupported_key_type" class="anchored"><td class="def constructor"><a href="#type-error.Unsupported_key_type" class="anchor"></a><code><span>| </span></code><code><span>`Unsupported_key_type <span class="keyword">of</span> int</span></code></td></tr><tr id="type-error.Unsupported_algorithm" class="anchored"><td class="def constructor"><a href="#type-error.Unsupported_algorithm" class="anchor"></a><code><span>| </span></code><code><span>`Unsupported_algorithm <span class="keyword">of</span> int</span></code></td></tr><tr id="type-error.Unsupported_elliptic_curve" class="anchored"><td class="def constructor"><a href="#type-error.Unsupported_elliptic_curve" class="anchor"></a><code><span>| </span></code><code><span>`Unsupported_elliptic_curve <span class="keyword">of</span> int</span></code></td></tr><tr id="type-error.Unsupported_attestation_format" class="anchored"><td class="def constructor"><a href="#type-error.Unsupported_attestation_format" class="anchor"></a><code><span>| </span></code><code><span>`Unsupported_attestation_format <span class="keyword">of</span> string</span></code></td></tr><tr id="type-error.Invalid_public_key" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_public_key" class="anchor"></a><code><span>| </span></code><code><span>`Invalid_public_key <span class="keyword">of</span> string</span></code></td></tr><tr id="type-error.Client_data_type_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Client_data_type_mismatch" class="anchor"></a><code><span>| </span></code><code><span>`Client_data_type_mismatch <span class="keyword">of</span> string</span></code></td></tr><tr id="type-error.Origin_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Origin_mismatch" class="anchor"></a><code><span>| </span></code><code><span>`Origin_mismatch <span class="keyword">of</span> string * string</span></code></td></tr><tr id="type-error.Rpid_hash_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Rpid_hash_mismatch" class="anchor"></a><code><span>| </span></code><code><span>`Rpid_hash_mismatch <span class="keyword">of</span> string * string</span></code></td></tr><tr id="type-error.Missing_credential_data" class="anchored"><td class="def constructor"><a href="#type-error.Missing_credential_data" class="anchor"></a><code><span>| </span></code><code><span>`Missing_credential_data</span></code></td></tr><tr id="type-error.Signature_verification" class="anchored"><td class="def constructor"><a href="#type-error.Signature_verification" class="anchor"></a><code><span>| </span></code><code><span>`Signature_verification <span class="keyword">of</span> string</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The variant of errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_error" class="anchored"><a href="#val-pp_error" class="anchor"></a><code><span><span class="keyword">val</span> pp_error : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span>[&lt; <a href="#type-error">error</a> ]</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_error ppf e</code> pretty-prints the error <code>e</code> on <code>ppf</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-challenge" class="anchored"><a href="#type-challenge" class="anchor"></a><code><span><span class="keyword">type</span> challenge</span></code></div><div class="spec-doc"><p>The abstract type of challenges.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-generate_challenge" class="anchored"><a href="#val-generate_challenge" class="anchor"></a><code><span><span class="keyword">val</span> generate_challenge : <span>?size:int <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-challenge">challenge</a> * string</span></code></div><div class="spec-doc"><p><code>generate_challenge ~size ()</code> generates a new challenge, and returns a pair of the challenge and its Base64 URI safe encoding.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if size is smaller than 16.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-challenge_to_string" class="anchored"><a href="#val-challenge_to_string" class="anchor"></a><code><span><span class="keyword">val</span> challenge_to_string : <span><a href="#type-challenge">challenge</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>challenge_to_string c</code> is a string representing this challenge.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-challenge_of_string" class="anchored"><a href="#val-challenge_of_string" class="anchor"></a><code><span><span class="keyword">val</span> challenge_of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-challenge">challenge</a> option</span></span></code></div><div class="spec-doc"><p><code>challenge_of_string s</code> decodes <code>s</code> as a challenge.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-challenge_equal" class="anchored"><a href="#val-challenge_equal" class="anchor"></a><code><span><span class="keyword">val</span> challenge_equal : <span><a href="#type-challenge">challenge</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-challenge">challenge</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>challenge_equal a b</code> is <code>true</code> if <code>a</code> and <code>b</code> are the same challenge.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-credential_id" class="anchored"><a href="#type-credential_id" class="anchor"></a><code><span><span class="keyword">type</span> credential_id</span><span> = string</span></code></div><div class="spec-doc"><p>The type of credential identifiers.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-credential_data" class="anchored"><a href="#type-credential_data" class="anchor"></a><code><span><span class="keyword">type</span> credential_data</span><span> = </span><span>{</span></code><table><tr id="type-credential_data.aaguid" class="anchored"><td class="def record field"><a href="#type-credential_data.aaguid" class="anchor"></a><code><span>aaguid : string;</span></code></td></tr><tr id="type-credential_data.credential_id" class="anchored"><td class="def record field"><a href="#type-credential_data.credential_id" class="anchor"></a><code><span>credential_id : <a href="#type-credential_id">credential_id</a>;</span></code></td></tr><tr id="type-credential_data.public_key" class="anchored"><td class="def record field"><a href="#type-credential_data.public_key" class="anchor"></a><code><span>public_key : <span class="xref-unresolved">Mirage_crypto_ec</span>.P256.Dsa.pub;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The type for credential data.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-registration" class="anchored"><a href="#type-registration" class="anchor"></a><code><span><span class="keyword">type</span> registration</span><span> = </span><span>{</span></code><table><tr id="type-registration.user_present" class="anchored"><td class="def record field"><a href="#type-registration.user_present" class="anchor"></a><code><span>user_present : bool;</span></code></td></tr><tr id="type-registration.user_verified" class="anchored"><td class="def record field"><a href="#type-registration.user_verified" class="anchor"></a><code><span>user_verified : bool;</span></code></td></tr><tr id="type-registration.sign_count" class="anchored"><td class="def record field"><a href="#type-registration.sign_count" class="anchor"></a><code><span>sign_count : <span class="xref-unresolved">Stdlib</span>.Int32.t;</span></code></td></tr><tr id="type-registration.attested_credential_data" class="anchored"><td class="def record field"><a href="#type-registration.attested_credential_data" class="anchor"></a><code><span>attested_credential_data : <a href="#type-credential_data">credential_data</a>;</span></code></td></tr><tr id="type-registration.authenticator_extensions" class="anchored"><td class="def record field"><a href="#type-registration.authenticator_extensions" class="anchor"></a><code><span>authenticator_extensions : <span><span><span>(string * <span class="xref-unresolved">CBOR</span>.Simple.t)</span> list</span> option</span>;</span></code></td></tr><tr id="type-registration.client_extensions" class="anchored"><td class="def record field"><a href="#type-registration.client_extensions" class="anchor"></a><code><span>client_extensions : <span><span><span>(string * <span class="xref-unresolved">Yojson</span>.Safe.t)</span> list</span> option</span>;</span></code></td></tr><tr id="type-registration.certificate" class="anchored"><td class="def record field"><a href="#type-registration.certificate" class="anchor"></a><code><span>certificate : <span><span class="xref-unresolved">X509</span>.Certificate.t option</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The type for a registration.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-register_response" class="anchored"><a href="#type-register_response" class="anchor"></a><code><span><span class="keyword">type</span> register_response</span></code></div><div class="spec-doc"><p>The type for a register_response.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-register_response_of_string" class="anchored"><a href="#val-register_response_of_string" class="anchor"></a><code><span><span class="keyword">val</span> register_response_of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-register_response">register_response</a>, <a href="#type-json_decoding_error">json_decoding_error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>register_response_of_string s</code> decodes the json encoded response (consisting of a JSON dictionary with an attestationObject and clientDataJSON - both Base64 URI safe encoded). The result is a register_response or a decoding error.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-register" class="anchored"><a href="#val-register" class="anchor"></a><code><span><span class="keyword">val</span> register : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-register_response">register_response</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-challenge">challenge</a> * <a href="#type-registration">registration</a>, <a href="#type-error">error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>register t response</code> registers the response, and returns the used challenge and a registration. The challenge needs to be verified to be valid by the caller. If a direct attestation is used, the certificate is returned -- and the signature is validated to establish the trust chain between certificate and public key. The certificate should be validated by the caller.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-authentication" class="anchored"><a href="#type-authentication" class="anchor"></a><code><span><span class="keyword">type</span> authentication</span><span> = </span><span>{</span></code><table><tr id="type-authentication.user_present" class="anchored"><td class="def record field"><a href="#type-authentication.user_present" class="anchor"></a><code><span>user_present : bool;</span></code></td></tr><tr id="type-authentication.user_verified" class="anchored"><td class="def record field"><a href="#type-authentication.user_verified" class="anchor"></a><code><span>user_verified : bool;</span></code></td></tr><tr id="type-authentication.sign_count" class="anchored"><td class="def record field"><a href="#type-authentication.sign_count" class="anchor"></a><code><span>sign_count : <span class="xref-unresolved">Stdlib</span>.Int32.t;</span></code></td></tr><tr id="type-authentication.authenticator_extensions" class="anchored"><td class="def record field"><a href="#type-authentication.authenticator_extensions" class="anchor"></a><code><span>authenticator_extensions : <span><span><span>(string * <span class="xref-unresolved">CBOR</span>.Simple.t)</span> list</span> option</span>;</span></code></td></tr><tr id="type-authentication.client_extensions" class="anchored"><td class="def record field"><a href="#type-authentication.client_extensions" class="anchor"></a><code><span>client_extensions : <span><span><span>(string * <span class="xref-unresolved">Yojson</span>.Safe.t)</span> list</span> option</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The type for an authentication.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-authenticate_response" class="anchored"><a href="#type-authenticate_response" class="anchor"></a><code><span><span class="keyword">type</span> authenticate_response</span></code></div><div class="spec-doc"><p>The type for an authentication response.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-authenticate_response_of_string" class="anchored"><a href="#val-authenticate_response_of_string" class="anchor"></a><code><span><span class="keyword">val</span> authenticate_response_of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-authenticate_response">authenticate_response</a>, <a href="#type-json_decoding_error">json_decoding_error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>authentication_response_of_string s</code> decodes the response (a JSON dictionary of Base64 URI-safe encoded values: authenticatorData, clientDataJSON, signature, userHandle). If decoding fails, an error is reported.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-authenticate" class="anchored"><a href="#val-authenticate" class="anchor"></a><code><span><span class="keyword">val</span> authenticate : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Mirage_crypto_ec</span>.P256.Dsa.pub <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-authenticate_response">authenticate_response</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-challenge">challenge</a> * <a href="#type-authentication">authentication</a>, <a href="#type-error">error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>authenticate t public_key response</code> authenticates <code>response</code>, by checking the signature with the <code>public_key</code>. If it is valid, the used <code>challenge</code> is returned together with the authentication. The challenge needs to be validated by the caller, and then caller is responsible for looking up the public key corresponding to the credential id returned by the client web browser.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-transport" class="anchored"><a href="#type-transport" class="anchor"></a><code><span><span class="keyword">type</span> transport</span><span> = </span><span>[ </span></code><table><tr id="type-transport.Bluetooth_classic" class="anchored"><td class="def constructor"><a href="#type-transport.Bluetooth_classic" class="anchor"></a><code><span>| </span></code><code><span>`Bluetooth_classic</span></code></td></tr><tr id="type-transport.Bluetooth_low_energy" class="anchored"><td class="def constructor"><a href="#type-transport.Bluetooth_low_energy" class="anchor"></a><code><span>| </span></code><code><span>`Bluetooth_low_energy</span></code></td></tr><tr id="type-transport.Usb" class="anchored"><td class="def constructor"><a href="#type-transport.Usb" class="anchor"></a><code><span>| </span></code><code><span>`Usb</span></code></td></tr><tr id="type-transport.Nfc" class="anchored"><td class="def constructor"><a href="#type-transport.Nfc" class="anchor"></a><code><span>| </span></code><code><span>`Nfc</span></code></td></tr><tr id="type-transport.Usb_internal" class="anchored"><td class="def constructor"><a href="#type-transport.Usb_internal" class="anchor"></a><code><span>| </span></code><code><span>`Usb_internal</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type of FIDO U2F transports.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_transport" class="anchored"><a href="#val-pp_transport" class="anchor"></a><code><span><span class="keyword">val</span> pp_transport : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-transport">transport</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_transport ppf tranport</code> pretty-prints the <code>transport</code> on <code>ppf</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-transports_of_cert" class="anchored"><a href="#val-transports_of_cert" class="anchor"></a><code><span><span class="keyword">val</span> transports_of_cert : <span><span class="xref-unresolved">X509</span>.Certificate.t <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-transport">transport</a> list</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>transports_of_cert certficate</code> attempts to extract the FIDO U2F authenticator transports extension (OID 1.3.6.1.4.1.45724.2.1.1) from the <code>certificate</code>.</p></div></div></div></body></html>