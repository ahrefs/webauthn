<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Webauthn (webauthn.Webauthn)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">webauthn</a> &#x00BB; Webauthn</nav><h1>Module <code>Webauthn</code></h1><p>WebAuthn - authenticating users to services using public key cryptography</p><p>WebAuthn is a web standard published by the W3C. Its goal is to standardize an interfacefor authenticating users to web-based applications and services using public key cryptography. Modern web browsers support WebAuthn functionality.</p><p>WebAuthn provides two funcitons: register and authenticate. Usually the public and private keypair is stored on an external token (Yuikey etc.) or part of the platform (TPM). After the public key is registered, it can be used to authenticate to the same service.</p><p>This module implements at the moment only &quot;fido-u2f&quot; and &quot;none&quot; attestations with P256 keys.</p><p>A common use of this module is that on startup a <a href="index.html#type-t"><code>t</code></a> is created (using <a href="index.html#val-create"><code>create</code></a>). A public key can then be registered (<a href="index.html#val-register"><code>register</code></a>) with a server generated <a href="index.html#type-challenge"><code>challenge</code></a>. When this is successfull, the client can be authenticated <a href="index.html#val-authenticate"><code>authenticate</code></a>.</p><p>This module does not preserve a database of registered public keys, their credential ID, usernames and pending challenges - instead this data must be stored by a client of this API in a database or other persistent storage.</p><p><a href="https://w3c.github.io/webauthn/">WebAuthn specification at W3C.</a></p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of a webauthn state, containing the <code>origin</code>.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : string <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a>, string)</span> Stdlib.result</span></code></dt><dd><p><code>create origin</code> is a webauthn state, or an error if the origin does not meet the specification (schema must be https, the host must be a valid hostname. An optional port is supported: https://example.com:4444</p></dd></dl><dl><dt class="spec value" id="val-rpid"><a href="#val-rpid" class="anchor"></a><code><span class="keyword">val</span> rpid : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>rpid t</code> is the relying party ID. Specifically, it is the effective domain of the origin. Using registrable domain suffix as the relying party ID is currently unsupported.</p></dd></dl><dl><dt class="spec type" id="type-json_decoding_error"><a href="#type-json_decoding_error" class="anchor"></a><code><span class="keyword">type</span> json_decoding_error</code> = <code>[ </code><table class="variant"><tr id="type-json_decoding_error.Json_decoding" class="anchored"><td class="def constructor"><a href="#type-json_decoding_error.Json_decoding" class="anchor"></a><code>| </code><code>`Json_decoding <span class="keyword">of</span> string * string * string</code></td></tr></table><code> ]</code></dt><dd><p>The type os json decoding errors: context, message, and data.</p></dd></dl><dl><dt class="spec type" id="type-decoding_error"><a href="#type-decoding_error" class="anchor"></a><code><span class="keyword">type</span> decoding_error</code> = <code>[ </code><table class="variant"><tr id="type-decoding_error.json_decoding_error" class="anchored"><td class="def type"><a href="#type-decoding_error.json_decoding_error" class="anchor"></a><code>| </code><code><a href="index.html#type-json_decoding_error">json_decoding_error</a></code></td></tr><tr id="type-decoding_error.Base64_decoding" class="anchored"><td class="def constructor"><a href="#type-decoding_error.Base64_decoding" class="anchor"></a><code>| </code><code>`Base64_decoding <span class="keyword">of</span> string * string * string</code></td></tr><tr id="type-decoding_error.CBOR_decoding" class="anchored"><td class="def constructor"><a href="#type-decoding_error.CBOR_decoding" class="anchor"></a><code>| </code><code>`CBOR_decoding <span class="keyword">of</span> string * string * string</code></td></tr><tr id="type-decoding_error.Unexpected_CBOR" class="anchored"><td class="def constructor"><a href="#type-decoding_error.Unexpected_CBOR" class="anchor"></a><code>| </code><code>`Unexpected_CBOR <span class="keyword">of</span> string * string * <a href="../CBOR/Simple/index.html#type-t">CBOR.Simple.t</a></code></td></tr><tr id="type-decoding_error.Binary_decoding" class="anchored"><td class="def constructor"><a href="#type-decoding_error.Binary_decoding" class="anchor"></a><code>| </code><code>`Binary_decoding <span class="keyword">of</span> string * string * Cstruct.t</code></td></tr><tr id="type-decoding_error.Attestation_object_decoding" class="anchored"><td class="def constructor"><a href="#type-decoding_error.Attestation_object_decoding" class="anchor"></a><code>| </code><code>`Attestation_object_decoding <span class="keyword">of</span> string * string * string</code></td></tr></table><code> ]</code></dt><dd><p>The variant of decoding errors with the various encoding formats.</p></dd></dl><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code> = <code>[ </code><table class="variant"><tr id="type-error.decoding_error" class="anchored"><td class="def type"><a href="#type-error.decoding_error" class="anchor"></a><code>| </code><code><a href="index.html#type-decoding_error">decoding_error</a></code></td></tr><tr id="type-error.Unsupported_key_type" class="anchored"><td class="def constructor"><a href="#type-error.Unsupported_key_type" class="anchor"></a><code>| </code><code>`Unsupported_key_type <span class="keyword">of</span> int</code></td></tr><tr id="type-error.Unsupported_algorithm" class="anchored"><td class="def constructor"><a href="#type-error.Unsupported_algorithm" class="anchor"></a><code>| </code><code>`Unsupported_algorithm <span class="keyword">of</span> int</code></td></tr><tr id="type-error.Unsupported_elliptic_curve" class="anchored"><td class="def constructor"><a href="#type-error.Unsupported_elliptic_curve" class="anchor"></a><code>| </code><code>`Unsupported_elliptic_curve <span class="keyword">of</span> int</code></td></tr><tr id="type-error.Unsupported_attestation_format" class="anchored"><td class="def constructor"><a href="#type-error.Unsupported_attestation_format" class="anchor"></a><code>| </code><code>`Unsupported_attestation_format <span class="keyword">of</span> string</code></td></tr><tr id="type-error.Invalid_public_key" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_public_key" class="anchor"></a><code>| </code><code>`Invalid_public_key <span class="keyword">of</span> string</code></td></tr><tr id="type-error.Client_data_type_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Client_data_type_mismatch" class="anchor"></a><code>| </code><code>`Client_data_type_mismatch <span class="keyword">of</span> string</code></td></tr><tr id="type-error.Origin_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Origin_mismatch" class="anchor"></a><code>| </code><code>`Origin_mismatch <span class="keyword">of</span> string * string</code></td></tr><tr id="type-error.Rpid_hash_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Rpid_hash_mismatch" class="anchor"></a><code>| </code><code>`Rpid_hash_mismatch <span class="keyword">of</span> string * string</code></td></tr><tr id="type-error.Missing_credential_data" class="anchored"><td class="def constructor"><a href="#type-error.Missing_credential_data" class="anchor"></a><code>| </code><code>`Missing_credential_data</code></td></tr><tr id="type-error.Signature_verification" class="anchored"><td class="def constructor"><a href="#type-error.Signature_verification" class="anchor"></a><code>| </code><code>`Signature_verification <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></dt><dd><p>The variant of errors.</p></dd></dl><dl><dt class="spec value" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>[&lt; <a href="index.html#type-error">error</a> ]</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_error ppf e</code> pretty-prints the error <code>e</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec type" id="type-challenge"><a href="#type-challenge" class="anchor"></a><code><span class="keyword">type</span> challenge</code></dt><dd><p>The abstract type of challenges.</p></dd></dl><dl><dt class="spec value" id="val-generate_challenge"><a href="#val-generate_challenge" class="anchor"></a><code><span class="keyword">val</span> generate_challenge : <span>?&#8288;size:int</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-challenge">challenge</a> * string</code></dt><dd><p><code>generate_challenge ~size ()</code> generates a new challenge, and returns a pair of the challenge and its Base64 URI safe encoding.</p><dl><dt>raises Invalid_argument</dt><dd><p>if size is smaller than 16.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-challenge_to_string"><a href="#val-challenge_to_string" class="anchor"></a><code><span class="keyword">val</span> challenge_to_string : <a href="index.html#type-challenge">challenge</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>challenge_to_string c</code> is a string representing this challenge.</p></dd></dl><dl><dt class="spec value" id="val-challenge_of_string"><a href="#val-challenge_of_string" class="anchor"></a><code><span class="keyword">val</span> challenge_of_string : string <span>&#45;&gt;</span> <span><a href="index.html#type-challenge">challenge</a> option</span></code></dt><dd><p><code>challenge_of_string s</code> decodes <code>s</code> as a challenge.</p></dd></dl><dl><dt class="spec value" id="val-challenge_equal"><a href="#val-challenge_equal" class="anchor"></a><code><span class="keyword">val</span> challenge_equal : <a href="index.html#type-challenge">challenge</a> <span>&#45;&gt;</span> <a href="index.html#type-challenge">challenge</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>challenge_equal a b</code> is <code>true</code> if <code>a</code> and <code>b</code> are the same challenge.</p></dd></dl><dl><dt class="spec type" id="type-credential_id"><a href="#type-credential_id" class="anchor"></a><code><span class="keyword">type</span> credential_id</code><code> = string</code></dt><dd><p>The type of credential identifiers.</p></dd></dl><dl><dt class="spec type" id="type-credential_data"><a href="#type-credential_data" class="anchor"></a><code><span class="keyword">type</span> credential_data</code><code> = </code><code>{</code><table class="record"><tr id="type-credential_data.aaguid" class="anchored"><td class="def field"><a href="#type-credential_data.aaguid" class="anchor"></a><code>aaguid : string;</code></td></tr><tr id="type-credential_data.credential_id" class="anchored"><td class="def field"><a href="#type-credential_data.credential_id" class="anchor"></a><code>credential_id : <a href="index.html#type-credential_id">credential_id</a>;</code></td></tr><tr id="type-credential_data.public_key" class="anchored"><td class="def field"><a href="#type-credential_data.public_key" class="anchor"></a><code>public_key : Mirage_crypto_ec.P256.Dsa.pub;</code></td></tr></table><code>}</code></dt><dd><p>The type for credential data.</p></dd></dl><dl><dt class="spec type" id="type-registration"><a href="#type-registration" class="anchor"></a><code><span class="keyword">type</span> registration</code><code> = </code><code>{</code><table class="record"><tr id="type-registration.user_present" class="anchored"><td class="def field"><a href="#type-registration.user_present" class="anchor"></a><code>user_present : bool;</code></td></tr><tr id="type-registration.user_verified" class="anchored"><td class="def field"><a href="#type-registration.user_verified" class="anchor"></a><code>user_verified : bool;</code></td></tr><tr id="type-registration.sign_count" class="anchored"><td class="def field"><a href="#type-registration.sign_count" class="anchor"></a><code>sign_count : Stdlib.Int32.t;</code></td></tr><tr id="type-registration.attested_credential_data" class="anchored"><td class="def field"><a href="#type-registration.attested_credential_data" class="anchor"></a><code>attested_credential_data : <a href="index.html#type-credential_data">credential_data</a>;</code></td></tr><tr id="type-registration.authenticator_extensions" class="anchored"><td class="def field"><a href="#type-registration.authenticator_extensions" class="anchor"></a><code>authenticator_extensions : <span><span><span>(string * <a href="../CBOR/Simple/index.html#type-t">CBOR.Simple.t</a>)</span> list</span> option</span>;</code></td></tr><tr id="type-registration.client_extensions" class="anchored"><td class="def field"><a href="#type-registration.client_extensions" class="anchor"></a><code>client_extensions : <span><span><span>(string * Yojson.Safe.t)</span> list</span> option</span>;</code></td></tr><tr id="type-registration.certificate" class="anchored"><td class="def field"><a href="#type-registration.certificate" class="anchor"></a><code>certificate : <span>X509.Certificate.t option</span>;</code></td></tr></table><code>}</code></dt><dd><p>The type for a registration.</p></dd></dl><dl><dt class="spec type" id="type-register_response"><a href="#type-register_response" class="anchor"></a><code><span class="keyword">type</span> register_response</code></dt><dd><p>The type for a register_response.</p></dd></dl><dl><dt class="spec value" id="val-register_response_of_string"><a href="#val-register_response_of_string" class="anchor"></a><code><span class="keyword">val</span> register_response_of_string : string <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-register_response">register_response</a>, <a href="index.html#type-json_decoding_error">json_decoding_error</a>)</span> Stdlib.result</span></code></dt><dd><p><code>register_response_of_string s</code> decodes the json encoded response (consisting of a JSON dictionary with an attestationObject and clientDataJSON - both Base64 URI safe encoded). The result is a register_response or a decoding error.</p></dd></dl><dl><dt class="spec value" id="val-register"><a href="#val-register" class="anchor"></a><code><span class="keyword">val</span> register : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-register_response">register_response</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-challenge">challenge</a> * <a href="index.html#type-registration">registration</a>, <a href="index.html#type-error">error</a>)</span> Stdlib.result</span></code></dt><dd><p><code>register t response</code> registers the response, and returns the used challenge and a registration. The challenge needs to be verified to be valid by the caller. If a direct attestation is used, the certificate is returned -- and the signature is validated to establish the trust chain between certificate and public key. The certificate should be validated by the caller.</p></dd></dl><dl><dt class="spec type" id="type-authentication"><a href="#type-authentication" class="anchor"></a><code><span class="keyword">type</span> authentication</code><code> = </code><code>{</code><table class="record"><tr id="type-authentication.user_present" class="anchored"><td class="def field"><a href="#type-authentication.user_present" class="anchor"></a><code>user_present : bool;</code></td></tr><tr id="type-authentication.user_verified" class="anchored"><td class="def field"><a href="#type-authentication.user_verified" class="anchor"></a><code>user_verified : bool;</code></td></tr><tr id="type-authentication.sign_count" class="anchored"><td class="def field"><a href="#type-authentication.sign_count" class="anchor"></a><code>sign_count : Stdlib.Int32.t;</code></td></tr><tr id="type-authentication.authenticator_extensions" class="anchored"><td class="def field"><a href="#type-authentication.authenticator_extensions" class="anchor"></a><code>authenticator_extensions : <span><span><span>(string * <a href="../CBOR/Simple/index.html#type-t">CBOR.Simple.t</a>)</span> list</span> option</span>;</code></td></tr><tr id="type-authentication.client_extensions" class="anchored"><td class="def field"><a href="#type-authentication.client_extensions" class="anchor"></a><code>client_extensions : <span><span><span>(string * Yojson.Safe.t)</span> list</span> option</span>;</code></td></tr></table><code>}</code></dt><dd><p>The type for an authentication.</p></dd></dl><dl><dt class="spec type" id="type-authenticate_response"><a href="#type-authenticate_response" class="anchor"></a><code><span class="keyword">type</span> authenticate_response</code></dt><dd><p>The type for an authentication response.</p></dd></dl><dl><dt class="spec value" id="val-authenticate_response_of_string"><a href="#val-authenticate_response_of_string" class="anchor"></a><code><span class="keyword">val</span> authenticate_response_of_string : string <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-authenticate_response">authenticate_response</a>, <a href="index.html#type-json_decoding_error">json_decoding_error</a>)</span> Stdlib.result</span></code></dt><dd><p><code>authentication_response_of_string s</code> decodes the response (a JSON dictionary of Base64 URI-safe encoded values: authenticatorData, clientDataJSON, signature, userHandle). If decoding fails, an error is reported.</p></dd></dl><dl><dt class="spec value" id="val-authenticate"><a href="#val-authenticate" class="anchor"></a><code><span class="keyword">val</span> authenticate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Mirage_crypto_ec.P256.Dsa.pub <span>&#45;&gt;</span> <a href="index.html#type-authenticate_response">authenticate_response</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-challenge">challenge</a> * <a href="index.html#type-authentication">authentication</a>, <a href="index.html#type-error">error</a>)</span> Stdlib.result</span></code></dt><dd><p><code>authenticate t public_key response</code> authenticates <code>response</code>, by checking the signature with the <code>public_key</code>. If it is valid, the used <code>challenge</code> is returned together with the authentication. The challenge needs to be validated by the caller, and then caller is responsible for looking up the public key corresponding to the credential id returned by the client web browser.</p></dd></dl><dl><dt class="spec type" id="type-transport"><a href="#type-transport" class="anchor"></a><code><span class="keyword">type</span> transport</code> = <code>[ </code><table class="variant"><tr id="type-transport.Bluetooth_classic" class="anchored"><td class="def constructor"><a href="#type-transport.Bluetooth_classic" class="anchor"></a><code>| </code><code>`Bluetooth_classic</code></td></tr><tr id="type-transport.Bluetooth_low_energy" class="anchored"><td class="def constructor"><a href="#type-transport.Bluetooth_low_energy" class="anchor"></a><code>| </code><code>`Bluetooth_low_energy</code></td></tr><tr id="type-transport.Usb" class="anchored"><td class="def constructor"><a href="#type-transport.Usb" class="anchor"></a><code>| </code><code>`Usb</code></td></tr><tr id="type-transport.Nfc" class="anchored"><td class="def constructor"><a href="#type-transport.Nfc" class="anchor"></a><code>| </code><code>`Nfc</code></td></tr><tr id="type-transport.Usb_internal" class="anchored"><td class="def constructor"><a href="#type-transport.Usb_internal" class="anchor"></a><code>| </code><code>`Usb_internal</code></td></tr></table><code> ]</code></dt><dd><p>The type of FIDO U2F transports.</p></dd></dl><dl><dt class="spec value" id="val-pp_transport"><a href="#val-pp_transport" class="anchor"></a><code><span class="keyword">val</span> pp_transport : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-transport">transport</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_transport ppf tranport</code> pretty-prints the <code>transport</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec value" id="val-transports_of_cert"><a href="#val-transports_of_cert" class="anchor"></a><code><span class="keyword">val</span> transports_of_cert : X509.Certificate.t <span>&#45;&gt;</span> <span><span>(<span><a href="index.html#type-transport">transport</a> list</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>transports_of_cert certficate</code> attempts to extract the FIDO U2F authenticator transports extension (OID 1.3.6.1.4.1.45724.2.1.1) from the <code>certificate</code>.</p></dd></dl></div></body></html>